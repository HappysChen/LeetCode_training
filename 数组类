A、数组类
 一、二分查找
 
  1、二分法第一种写法
    第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。

    区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：

    while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
    if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
 2、二分法第二种写法
    如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

    有如下两点：

    while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
    if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，
    即：下一个查询区间不会去比较nums[middle]。

题型1：在排序数组中查找元素的第一个和最后一个位置
     给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

寻找左右边界:分别用两次二分查找进行
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int L = LeftBorad(nums, target);
        int R = RightBorad(nums, target);

        //分情况：
        //情况一：
        if (L == -2 || R == -2) return { -1,-1 };
        //情况三：
        if (R - L > 1) return { L + 1,R - 1 };
        //情况二
        return { -1,-1 };

    }
private:
    int RightBorad(vector<int>& nums, int target)    //寻找右区间
    {
        int left = 0;
        int right = nums.size() - 1;
        int midle;
        int rightBorader = -2;//记录为被记录的边界
        while (left <= right)
        {
            midle = left + (right - left) / 2;
            if (nums[midle] > target)  //target 在左区间
            {
                right = midle - 1;
            }
            else {     //在右区间
                left = midle + 1;
                rightBorader = left;
            }
        }
        return rightBorader;
    }

    int LeftBorad(vector<int>& nums, int target)    //寻找左区间
    {
        int left = 0;
        int right = nums.size() - 1;
        int midle;
        int leftBorader = -2;//记录为被记录的边界
        while (left <= right)
        {
            midle = left + (right - left) / 2;
            if (nums[midle] >= target)  //target 在左区间
            {
                right = midle - 1;
                leftBorader = right;
            }
            else {     //在左区间
                left = midle+1;
                
            }
        }
        return leftBorader;
    }
};

题型2：实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。
   分析：要实现x的n次幂函数，需要判断n的情况：
                                              1、n=0,pow=1;  
                                              2、n<0,pow=1.0/pow;
                                              3、n>0,奇数和偶数
     n为奇数时，如2的5次方，即n=5，可分为，n=(4+1),因此，在偶次幂的基础上再乘以基数
     n为偶数时，就很简单，就一直递归。
                                                                                                                                       
class Solution {
public:
    double myPow(double x, int n) {
     double sum = 1.00000;
		
        long long N=n;
		sum=n>0?QuikMui(x,N):1.0/QuikMui(x,-N);
        return sum;
    }
    
    double QuikMui(double x,long long N)
    {
        if(N==0) return 1.0;
        double y=QuikMui(x,N/2);
        return N%2==0? y*y:y*y*x;
    }

};

二、移除元素（重点是：快慢指针，即双指针）
   1、删除排序数组中的重复项
    给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
   
   2、删除排序数组中的重复项II 
    给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
   （在上面那题的基础上添加一个条件变量flag）或者参看官方解题
   
   3、移除零
     给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
     
     示例:
	输入: [0,1,0,3,12]
	输出: [1,3,12,0,0]
   方法一、（自己写）
   if (nums.size() == 0 || nums.empty())
		{
			return;
		}

		int slow = 0;
		int fast = 0;
		int flag = 0;//记录0的个数
		//int val = nums[0];
		for (fast = 0; fast < nums.size(); fast++)
		{
			if (0 != nums[fast])
			{
				nums[slow++] = nums[fast];
			}
            else
              flag++;
			
		}
        for (int i = 0; i < flag; i++)
		{
			nums[slow + i] = 0;
		}
		
     第二种：（解题）
   //两个指针i和j
		int j = 0;
		for(int i=0;i<nums.length;i++) {
			//当前元素!=0，就把其交换到左边，等于0的交换到右边
			if(nums[i]!=0) {
				int tmp = nums[i];
				nums[i] = nums[j];
				nums[j++] = tmp;
			}
		}


三、滑动窗口
   所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。
   
   题型：给定一个含有 n 个正整数的数组和一个正整数 target 。
         找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
	示例 1：

	输入：target = 7, nums = [2,3,1,2,4,3]
	输出：2
	解释：子数组 [4,3] 是该条件下的长度最小的子数组。
	
	在本题中实现滑动窗口，主要确定如下三点：

	窗口内是什么？
	如何移动窗口的起始位置？
	如何移动窗口的结束位置？
	窗口就是 满足其和 ≥ target 的长度最小的 连续 子数组。

	窗口的起始位置如何移动：如果当前窗口的值大于target了，窗口就要向前移动了（也就是该缩小了）。

	窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

     int minSubArrayLen(int target, vector<int>& nums) {
        int i = 0;
        int j = 0;
        int sum = 0;
        int result = INT32_MAX;  
        int length = 0;       //子数组长度
        for (j = 0; j < nums.size(); j++)
        {
            sum += nums[j];
            //result++;      //不能自加
            while (sum >= target)
            {
                length = j - i + 1;
                result = result < length ? result : length;
                sum -= nums[i++];
            }
        }
        return  result==INT32_MAX?0:result;  //判断是否被赋值
    }


一、中心扩展法
    中心拓展法的思路是，以原始字符串中的任意一个位置开始（可以是一个字符，也可以是两个字符中间的位置），向两边拓展，如果两边的字母相同，我们就可以继续扩展。
例如，用 P(i,j)表示字符串 s 的第 i 到 jj个字母组成的串，从 P(i+1,j-1)扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。

例子：最长回文子串

class Solution
{
   string LongestPalindrome(string s){
     if(s.length()==0 || s==" ") return 0;
     int left=0;    //左部分
     int right =0; //右部分
     int len =0;   //记录回文字符串数
     int maxlen =0;//计算最长的
     int start = 0;//记录回文字符串的开始位置
     
     for(int i=0;i<s.length();i++)
     {
       left =i-1;
       right=i+1;
       while(left>=0 && s[left]==s[i])
       { 
          left--;
          len++;
       }
       while(right<s.length()&&s[right]==s[i])
       {
          right++;
          len++;
       }
       while(left>=0 && left<right && s[left]==s[right])
       {
         left--;
         right++;
         len+=2;
       }
     
     if(len>maxlen)
     {
       maxlen=len;
       start=left<=0?0:left;
     }
     len=1;
    }
    return s.substr(start,maxlen);
   }
   
 };















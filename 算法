A、数组类
 一、二分查找
 
  1、二分法第一种写法
    第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。

    区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：

    while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
    if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
 2、二分法第二种写法
    如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

    有如下两点：

    while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
    if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，
    即：下一个查询区间不会去比较nums[middle]。

题型：在排序数组中查找元素的第一个和最后一个位置
     给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

寻找左右边界:分别用两次二分查找进行




一、中心扩展法
    中心拓展法的思路是，以原始字符串中的任意一个位置开始（可以是一个字符，也可以是两个字符中间的位置），向两边拓展，如果两边的字母相同，我们就可以继续扩展。
例如，用 P(i,j)表示字符串 s 的第 i 到 jj个字母组成的串，从 P(i+1,j-1)扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。

例子：最长回文子串

class Solution
{
   string LongestPalindrome(string s){
     if(s.length()==0 || s==" ") return 0;
     int left=0;    //左部分
     int right =0; //右部分
     int len =0;   //记录回文字符串数
     int maxlen =0;//计算最长的
     int start = 0;//记录回文字符串的开始位置
     
     for(int i=0;i<s.length();i++)
     {
       left =i-1;
       right=i+1;
       while(left>=0 && s[left]==s[i])
       { 
          left--;
          len++;
       }
       while(right<s.length()&&s[right]==s[i])
       {
          right++;
          len++;
       }
       while(left>=0 && left<right && s[left]==s[right])
       {
         left--;
         right++;
         len+=2;
       }
     
     if(len>maxlen)
     {
       maxlen=len;
       start=left<=0?0:left;
     }
     len=1;
    }
    return s.substr(start,maxlen);
   }
   
 };


二、动态规划
     动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。
因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。
     动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。
     简单地说，问题能够分解成子问题来解决。
  
  涉及的题型：
    动态基础
    背包问题
    打家劫舍
    股票问题
    子序列问题
    
  解题步骤：
    dp数组以及下标的含义
    递推公式
    dp数组如何初始化
    遍历顺序
    打印dp数组
    
注意：for(int i=0; ; )
        for(j=  ;  ; )
    这两个循环的顺序
    
例子：
  1、斐波那契数列
    分析：
     当n=0时，sum = 1；
     当n=1时，sum = 1;
     当n=2时，sum = 2;
     当n=3时，sum = 3；
     当n=4时，sum = 5；
     ...
     1）得到递推公式： 第n个时，sum=sum(n-1)+sum(n-2);
     2）定义数组： dp[i] 表示第i时的值
                  dp[i]=dp[i-1]+dp[i-2];
     3)数组初始化：
        由前面分析得知，dp[0]=1;
                       dp[1]=1;
     4)遍历顺序：
          for(int i=2;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
     5)打印数组
     
  2、爬楼梯 （与斐波那契数列差不多）
     问题：有n个阶梯，你有多少中方法能爬到第n个阶梯
     分析：
        当n=1时，1种
        当n=2时，2种
        当n=3时，3种
        当n=4时，5种
        当n=5时，8种
         ....
      1)得到递推公式：
             有n个阶梯，有sum(n)=sum(n-2)+sum(n-1)种
      2）定义数组：
             dp[i]表示爬到第i个阶梯时，有dp[i]种方法
             dp[i]=dp[i-2]+dp[i-1];
      3）数组初始化：
             由前面分析得：
              知道dp[0]=1是没有意义的
              因此：dp[1]=1;
                    dp[2]=2;
      4)遍历顺序：
            4)遍历顺序：
          for(int i=3;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
      5)打印数组
  
  3、背包问题
    A、0-1背包问题：
      题目： 有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是p[i]。求解将哪些物品装入背包可使价值总和最大。

从这个题目中可以看出，01背包的特点就是：每种物品仅有一件，可以选择放或不放。
    
    注意：每个物品的状态只有两种：放与不放，就是0与1
   1）运用二维数组解题：dp[i][j]，表示：在0-i之间任何物品选取放入容量为j的背包中
   2）分析：  (假设三个物品的重量分别为1、3、4，价值分别为：15、30、40，背包的容量为：4)
        容量j:  0  1  2  3  4    
物品i:       1
             2
             3
      对于物品i：
          不放入背包时：得到的价值为：dp[i-1][j]，不放入，为什么还是j，因为不放入物品i，背包的容量是没有变化的，还是j
          放入背包时：  得到的价值为：dp[i-1][j-w[i]]+p[i],其中dp[i-1][j-w[i]]为什么还是i-1,这是因为表示前面i-1个物品的，然后你又放入这个物品进入背包，
                                     所以背包的容量要减去物品i的重量，最后，加上该物品的价值，即为放入物品i之后，背包中的物品的所有价值。
  3)递推公式： 因为要使背包中的物品总价值最大，即为dp[i-1][j]与dp[i-1][j-w[i]]中最大的那个，则可得出递推公式：
               dp[i][j]=dp[i-1][j]+dp[i-1][j-w[i]].
          
  4）遍历顺序：
              for(int i=1;i<N;i++)  //先遍历物品
                 for(int j=0;j<v;j++)  //遍历容量
              
              也可以颠倒过来，注意这只是针对二维数组解题时，一维时不适用
      初始化：
        容量j:  0   1  2  3  4    
物品i:       1  0  15 15 15 15
             2  0  -1 -1 -1 -1
             3  0  -1 -1 -1 -1

创建和初始化数组：
     vector<vector<int>>dp(weight+1,0),vector<int>())












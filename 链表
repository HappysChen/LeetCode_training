链表类

一、定义：
  // 单链表
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };

题型1： 移除链表元素
      给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

分析：
    移除元素，有几种情况：
                         1、正常的情况，为空表，返回空
                         2、删除链表的第一个元素或者连续删除头结点
                         3、删除尾节点
                         4、连续删除中间节点
    解法一、
           直接用原来的链表进行删除--->该解法需要考虑上面几个情况下
           while (head!=nullptr && head->val == val) {   //情况2
            ListNode* temp = head;
            head=head->next;
            delete temp;
          }
           if (head== nullptr)          //如果是已知删除头结点之后或者原来就是空链表  情况1和情况2
          {
            return nullptr;
          }
          ListNode* p=head;
          while (p!=nullptr && p->next!= nullptr)   //情况3和情况4  
          {
            if (p->next->val == val)
            {

              ListNode* temp = p->next;
              p->next= temp->next;
              //cout << p->val;
              delete temp;
                //p = p->next;
              //p = p->next;
            }
            else
               p = p->next;
           
      解法二、
              创建一个虚拟节点  -->该方法不需要考虑上面哪几种情况，但是需要注意如何将头结点恢复
              ListNode* dm = new ListNode(0); //虚拟节点
                dm->next = head;               //令其接入头结点
                if (dm->next == nullptr)      //判空
                {
                  delete dm;
                  return nullptr;
                }

                ListNode* cur = dm;                
                while (cur->next!=nullptr)
                {
                  if (cur->next->val == val)
                  {
                    ListNode* temp = cur->next;
                    cur->next = cur->next->next;
                    delete temp;
                  }
                  else
                    cur = cur->next;
                }

                head = dm->next;      //恢复头结点
                delete dm;            //要记得释放
                return head; 

题型2：设计链表(要好好思考一下)

       设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。
  val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

  在链表类中实现这些功能：

  get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
  addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
  addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
  addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。
                         如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
  deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。


  示例：

  MyLinkedList linkedList = new MyLinkedList();
  linkedList.addAtHead(1);
  linkedList.addAtTail(3);
  linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
  linkedList.get(1);            //返回2
  linkedList.deleteAtIndex(1);  //现在链表是1-> 3
  linkedList.get(1);            //返回3


  代码看：电脑VS的DesignLink文件
  
  要掌握添加头结点、添加尾节点
 
  void addAtHead(int val) {      //添加头结点
        ListNode* newNode = new ListNode(val);
        newNode->next = mylist->next;
        mylist->next = newNode;
        size++;  //节点数自加
      
        //this = list;
    }

    void addAtTail(int val) {      //添加尾节点
        ListNode* newNode = new ListNode(val);
        ListNode* cur = mylist;
        /*
        if (cur->next == nullptr)
        {
            mylist->next = newNode;
            newNode->next = mylist->next;
            size++;
            delete cur;
            return ;
        }
        */
        ListNode* temp = mylist;
        while (temp->next!=nullptr)
        {
            temp = temp->next;
        }
        temp->next = newNode;
        //newNode->next = nullptr;
        size++;
    }
 
题型3、反转链表
     给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
     输入：head = [1,2,3,4,5]
     输出：[5,4,3,2,1]
 
     首先是要翻转，所以可以用双指针法，链表的双指针法与数组的不同，链表中前驱指针需要一个变量保存下一个节点（当然也可以用头结点来进行遍历，然后重新复制给前驱节点）
     ListNode* reverseList(ListNode* head) {
      if (head == nullptr || head->next == nullptr)return head;
		ListNode* cur =head;
		ListNode* pre = nullptr; //必须要指向为NULL
		//ListNode* temp;        //保存cur下一个节点
		//pre->next = nullptr;
		/*
		while (cur!= nullptr)
		{   
			temp = cur->next;			
			cur->next = pre;
			pre = cur;
			
			cur = temp;
					
		}*/
		while (head != nullptr)
		{
			cur = head;
			head = head->next;
			cur->next = pre;
			pre = cur;
		}
        //delete cur;
        //delete temp;
		return pre;
    }
 
 也可以用递归法：逻辑和双指针法是一样的
 
 同样是当cur为空的时候循环结束，不断将cur指向pre的过程。
 关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。
  
  
还有自己对链表还有一些理解误区：
   1、认为遍历到最后一个节点的话，需要while(head.next!=nullptr),其实不是，而是while(head!=nullptr)，需要用到while(head.next!=nullptr)时，则是要提前查看下一个节点，
      如上面删除链表元素的操作。if (cur->next->val == val){} 这样就可以对下一个节点的提前操作
   2、temp=cur.next; temp是用来保存cur的下一个节点，不管cur.next指向谁都不会影响temp指向cur的下一个节点，不要认为，cur.next=pre;temp就指向了pre了；

题型4、两两交换链表中的节点
      给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
  
  分析：这题是要交换头结点的，所以要创建一个虚节点来指向头结点。
        
  题解1、交换方法：
         
     dm--》1--》2--》3--》4
     
     步骤一：创建一个节点cur指向虚节点 dm, 然后指向第2个节点
     步骤二：节点2指向节点1
     步骤三：节点1指向节点3
     然后：cur.next指向cur.next.next;
     
     最后将节点dm->next返回
              
     要保护的节点：要交换的两个节点，即头结点和头结点的下一个节点，同时也要保护头结点  

     循环的条件：下一个节点和下一个节点的节点不为空
     
              while (cur->next!=nullptr && cur->next->next!=nullptr )
		{
			/*
			temp = cur->next;
			temp1 = cur->next->next->next;

			cur->next = cur->next->next;
			cur->next->next = temp;           //为什么是cur.next.next 指向temp 而不是cur.next.next.next,
											  //是因为cur.next已经指向了cur.next.next了，
											  // 所以前部分cur.next的下一个next就是cur.next.next.next
			cur->next->next->next = temp1;    //这个也是跟上面一样的理解

			cur = cur->next->next;
			*/
			
		}

 题解2、 
             dm--》1--》2--》3--》4
     
	     步骤一：创建一个节点cur指向虚节点 dm, 然后.next指向第2个节点
	     步骤二：节点1指向节点3
	     步骤三：节点2指向节点1
	     
	     然后节点cur指向右边节点

     最后将节点dm->next返回
              
     要保护的节点：要交换的两个节点，即头结点和头结点的下一个节点，同时也要保护头结点  

     循环的条件：下一个节点和下一个节点的节点不为空

     ListNode* l = cur->next;
     ListNode* r = cur->next->next;

     cur->next = r;	
     l->next = r->next;
     r->next = l;
     cur = r;

这种方法比第一种方法比较好理解：但疑问是：为什么先是步骤二先才到步骤三



总结：
    1、当链表中的操作需要改变头结点，则创建一个虚节点来指向原链表的头结点，保护头结点。
    2、如果想不明白逻辑交换，则多创建几个结点来保护结点。
    3、对于链表的题：要确定需要保护的哪些节点，边界是什么
    4、是否需要用到双指针
    
 例如下题：
  
 题型4、删除链表的倒数第 N 个结点
       给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
       
       输入：head = [1,2,3,4,5], n = 2
       输出：[1,2,3,5]
  分析：
       双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。
       就是要fast与low之间相隔n个节点，这时，fast与low一起走，直到fast走到链表末尾时，此时low的下一个节点就是要删除的节点。
       
 步骤1：由于有可能是删除头结点，所以需要改变头结点，所以要创建一个虚拟节点更方便。
 步骤2：没有需要保护的节点
 步骤3：边界，节点不为空 且 n--
 步骤4：fast指针提前下一个节点，即需要走n+1个节点，这样fast和low才能间隔n个节点
 
 最后返回 dm.next。
 
        代码：
               if (head == nullptr) return head;
		ListNode* dm = new ListNode(0);
		dm->next = head;
		ListNode* fast = dm;
		ListNode* low = dm;
		while (fast != nullptr && n--)
		{
			fast = fast->next;
		}
		fast = fast->next;
		while (fast != nullptr)
		{
			fast = fast->next;
			low = low->next;
		}
		//low = low->next;
		low->next = low->next->next;
		return dm->next;












链表类

一、定义：
  // 单链表
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };

题型1： 移除链表元素
      给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

分析：
    移除元素，有几种情况：
                         1、正常的情况，为空表，返回空
                         2、删除链表的第一个元素或者连续删除头结点
                         3、删除尾节点
                         4、连续删除中间节点
    解法一、
           直接用原来的链表进行删除--->该解法需要考虑上面几个情况下
           while (head!=nullptr && head->val == val) {   //情况2
            ListNode* temp = head;
            head=head->next;
            delete temp;
          }
           if (head== nullptr)          //如果是已知删除头结点之后或者原来就是空链表  情况1和情况2
          {
            return nullptr;
          }
          ListNode* p=head;
          while (p!=nullptr && p->next!= nullptr)   //情况3和情况4  
          {
            if (p->next->val == val)
            {

              ListNode* temp = p->next;
              p->next= temp->next;
              //cout << p->val;
              delete temp;
                //p = p->next;
              //p = p->next;
            }
            else
               p = p->next;
           
      解法二、
              创建一个虚拟节点  -->该方法不需要考虑上面哪几种情况，但是需要注意如何将头结点恢复
              ListNode* dm = new ListNode(0); //虚拟节点
                dm->next = head;               //令其接入头结点
                if (dm->next == nullptr)      //判空
                {
                  delete dm;
                  return nullptr;
                }

                ListNode* cur = dm;                
                while (cur->next!=nullptr)
                {
                  if (cur->next->val == val)
                  {
                    ListNode* temp = cur->next;
                    cur->next = cur->next->next;
                    delete temp;
                  }
                  else
                    cur = cur->next;
                }

                head = dm->next;      //恢复头结点
                delete dm;            //要记得释放
                return head; 

题型2：设计链表(要好好思考一下)

       设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。
  val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

  在链表类中实现这些功能：

  get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
  addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
  addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
  addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。
                         如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
  deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。


  示例：

  MyLinkedList linkedList = new MyLinkedList();
  linkedList.addAtHead(1);
  linkedList.addAtTail(3);
  linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
  linkedList.get(1);            //返回2
  linkedList.deleteAtIndex(1);  //现在链表是1-> 3
  linkedList.get(1);            //返回3


  代码看：电脑VS的DesignLink文件
  
  要掌握添加头结点、添加尾节点
 
  void addAtHead(int val) {      //添加头结点
        ListNode* newNode = new ListNode(val);
        newNode->next = mylist->next;
        mylist->next = newNode;
        size++;  //节点数自加
      
        //this = list;
    }

    void addAtTail(int val) {      //添加尾节点
        ListNode* newNode = new ListNode(val);
        ListNode* cur = mylist;
        /*
        if (cur->next == nullptr)
        {
            mylist->next = newNode;
            newNode->next = mylist->next;
            size++;
            delete cur;
            return ;
        }
        */
        ListNode* temp = mylist;
        while (temp->next!=nullptr)
        {
            temp = temp->next;
        }
        temp->next = newNode;
        //newNode->next = nullptr;
        size++;
    }
 





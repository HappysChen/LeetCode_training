一、中心扩展法
    中心拓展法的思路是，以原始字符串中的任意一个位置开始（可以是一个字符，也可以是两个字符中间的位置），向两边拓展，如果两边的字母相同，我们就可以继续扩展。
例如，用 P(i,j)表示字符串 s 的第 i 到 jj个字母组成的串，从 P(i+1,j-1)扩展到 P(i,j)；如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。

例子：最长回文子串

class Solution
{
   string LongestPalindrome(string s){
     if(s.length()==0 || s==" ") return 0;
     int left=0;  //左部分
     int right =0; //右部分
     int len =0;   //记录回文字符串数
     int maxlen =0;//计算最长的
     int start = 0;//记录回文字符串的开始位置
     
     for(int i=0;i<s.length();i++)
     {
       left =i-1;
       right=i+1;
       while(left>=0 && s[left]==s[i])
       { 
          left--;
          len++;
       }
       while(right<s.length()&&s[right]==s[i])
       {
          right++;
          len++;
       }
       while(left>=0 && left<right && s[left]==s[right])
       {
         left--;
         right++;
         len+=2;
       }
     
     if(len>maxlen)
     {
       maxlen=len;
       start=left<=0?0:left;
     }
     len=1;
    }
    return s.substr(start,maxlen);
   }
   
 };


二、动态规划
     动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。
因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。
     动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。
     简单地说，问题能够分解成子问题来解决。
  
  涉及的题型：
    动态基础
    背包问题
    打家劫舍
    股票问题
    子序列问题
    
  解题步骤：
    dp数组以及下标的含义
    递推公式
    dp数组如何初始化
    遍历顺序
    打印dp数组
    
注意：for(int i=0; ; )
        for(j=  ;  ; )
    这两个循环的顺序
    
例子：
  1、斐波那契数列
    分析：
     当n=0时，sum = 1；
     当n=1时，sum = 1;
     当n=2时，sum = 2;
     当n=3时，sum = 3；
     当n=4时，sum = 5；
     ...
     1）得到递推公式： 第n个时，sum=sum(n-1)+sum(n-2);
     2）定义数组： dp[i] 表示第i时的值
                  dp[i]=dp[i-1]+dp[i-2];
     3)数组初始化：
        由前面分析得知，dp[0]=1;
                       dp[1]=1;
     4)遍历顺序：
          for(int i=2;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
     5)打印数组
     
  2、爬楼梯 （与斐波那契数列差不多）
     问题：有n个阶梯，你有多少中方法能爬到第n个阶梯
     分析：
        当n=1时，1种
        当n=2时，2种
        当n=3时，3种
        当n=4时，5种
        当n=5时，8种
         ....
      1)得到递推公式：
             有n个阶梯，有sum(n)=sum(n-2)+sum(n-1)种
      2）定义数组：
             dp[i]表示爬到第i个阶梯时，有dp[i]种方法
             dp[i]=dp[i-2]+dp[i-1];
      3）数组初始化：
             由前面分析得：
              知道dp[0]=1是没有意义的
              因此：dp[1]=1;
                    dp[2]=2;
      4)遍历顺序：
            4)遍历顺序：
          for(int i=3;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
      5)打印数组

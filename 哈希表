一、哈希表法：
         哈希表是根据关键码的值而直接进行访问的数据结构。

那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。

1、哈希函数：用于计算索引

2、碰撞检测：当计算的索引值大于哈希表的大小
          一般哈希碰撞有两种解决方法， 拉链法和线性探测法

         1）拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
         
         2）线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题

3、哈希表法选择的数据结构：
                          数组
                          set （集合）
                          map(映射)
   当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，
   如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。                       
   那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。
   
   虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，
   所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。map也是一样的道理。

题型1、有效的字母异位词
         给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

         示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

         示例 2: 输入: s = "rat", t = "car" 输出: false

         说明: 你可以假设字符串只包含小写字母。
     
     首先：如果两个字符串长度不一样，则它们肯定不是
         其次，由于是小写，则有26个字母，而且ASCII码值都是比>=a的，所以 利用该字母与a的差值为索引，则该索引的数组值则自加。
          
       


























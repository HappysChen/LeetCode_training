一、哈希表法：
         哈希表是根据关键码的值而直接进行访问的数据结构。

那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。

1、哈希函数：用于计算索引

2、碰撞检测：当计算的索引值大于哈希表的大小
          一般哈希碰撞有两种解决方法， 拉链法和线性探测法

         1）拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
         
         2）线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题

3、哈希表法选择的数据结构：
                          数组
                          set （集合）
                          map(映射)
   当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，
   如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。                       
   那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。
   
   虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，
   所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。map也是一样的道理。

题型1、有效的字母异位词
         给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

         示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

         示例 2: 输入: s = "rat", t = "car" 输出: false

         说明: 你可以假设字符串只包含小写字母。
     
     首先：如果两个字符串长度不一样，则它们肯定不是
         其次，由于是小写，则有26个字母，而且ASCII码值都是比>=a的，所以 利用该字母与a的差值为索引，则该索引的数组值则自加。
                     
            bool isAnagram(string s, string t) {
		int record[26] = { 0 };
		for (int i = 0; i < s.size(); i++)
		{
			record[s[i] - 'a']++;
		}

		for (int i = 0; i < t.size(); i++)
		{
			record[t[i] - 'a']--;
		}

		for (int i = 0; i < 26; i++)
		{
			if (record[i] != 0)
			{
				return false;
			}
		}
		return true;
	    }                 

 题型2、两个数组的交集
       给定两个数组，编写一个函数来计算它们的交集。

         示例 1：

         输入：nums1 = [1,2,2,1], nums2 = [2,2]
         输出：[2]
         
         示例 2：

         输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
         输出：[9,4]

       这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。

注意题目特意说明：输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序

         而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

         此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

         std::set
         std::multiset
         std::unordered_set
         std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，
                所以选择unordered_set。
              
                 vector<int> vec;
		if (nums1.empty() || nums2.empty()) return vec;

		unordered_set<int> se;
		unordered_set<int>tm;
		for (int i = 0; i < nums1.size(); i++)
		{
			se.insert(nums1[i]);
		}
		
		for (int i = 0; i < nums2.size(); i++)
		{
			if (se.find(nums2[i]) != se.end())
			{				
				tm.insert(nums2[i]);
			}
		}

		for (auto iter=tm.begin();iter!=tm.end();iter++)
		{
			vec.push_back(*iter);
		}
		return vec;       
         
       精简版：
            class Solution {
                  public:
                      vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
                          unordered_set<int> result_set; // 存放结果
                          unordered_set<int> nums_set(nums1.begin(), nums1.end());
                          for (int num : nums2) {
                              // 发现nums2的元素 在nums_set里又出现过
                              if (nums_set.find(num) != nums_set.end()) {
                                  result_set.insert(num);
                              }
                          }
                          return vector<int>(result_set.begin(), result_set.end());
                      }
                  };




















